{"version":3,"sources":["aldeed:tabular/common.js","aldeed:tabular/server/tabular.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8D;;AAEA,wB;;AAEA,kB;;AAEA,oC;AACA,kB;;AAEA,iB;AACA,kE;AACA,G;;AAEA,sB;AACA,+D;AACA,G;AACA,2B;;AAEA,0D;AACA,qE;AACA,G;AACA,uC;;AAEA,iD;;AAEA,gE;AACA,sF;AACA,mC;;AAEA,mC;AACA,6B;AACA,yC;AACA,+C;;AAEA,uC;AACA,oB;AACA,sD;AACA,4B;AACA,O;AACA,8B;AACA,G;;AAEA,mC;;AAEA,yB;AACA,kE;AACA,G;;AAEA,oI;;AAEA,iC;AACA,E;;;;;;;;;;;;;;;;;;;ACnDA,kD;;AAEA,E;AACA,uD;AACA,E;AACA,4D;AACA,+D;AACA,8D;AACA,4D;AACA,iE;AACA,E;AACA,+D;AACA,gE;AACA,sD;AACA,E;AACA,8D;AACA,4B;AACA,G;;AAEA,wE;AACA,kB;;AAEA,2B;AACA,oB;AACA,wC;;AAEA,sC;AACA,e;AACA,uE;AACA,iB;AACA,W;AACA,G;;AAEA,mE;AACA,0B;AACA,wC;AACA,G;;AAEA,uD;AACA,+E;AACA,iB;AACA,W;AACA,G;;AAEA,qE;AACA,2F;AACA,iB;AACA,W;AACA,G;;AAEA,oE;AACA,G;;AAEA,oF;AACA,kB;;AAEA,2B;AACA,6D;AACA,wD;AACA,sB;AACA,uB;;AAEA,sC;AACA,e;AACA,+I;AACA,G;;AAEA,2D;AACA,+B;AACA,oB;AACA,c;AACA,G;;AAEA,uD;AACA,sD;AACA,sD;AACA,0D;AACA,oD;AACA,uE;AACA,iB;AACA,W;AACA,G;;AAEA,4B;;AAEA,2D;AACA,mD;AACA,2D;AACA,G;;AAEA,4D;AACA,oD;AACA,qD;AACA,mB;AACA,6C;AACA,oD;AACA,8B;AACA,+B;AACA,Y;AACA,mD;AACA,K;AACA,G;;AAEA,qB;AACA,e;AACA,iB;AACA,oB;AACA,I;;AAEA,yB;AACA,wB;AACA,4B;AACA,G;;AAEA,oE;;AAEA,6D;AACA,mB;AACA,K;;AAEA,wE;;AAEA,0B;AACA,4B;AACA,2C;;AAEA,kB;AACA,6B;AACA,qD;AACA,sD;AACA,4B;AACA,iC;AACA,mC;AACA,M;;AAEA,sB;AACA,kD;AACA,yD;AACA,Y;AACA,gD;AACA,uD;AACA,yB;AACA,K;AACA,G;;AAEA,4D;AACA,2B;AACA,+C;AACA,0B;AACA,0B;AACA,e;AACA,O;;AAEA,6B;AACA,iC;AACA,sB;AACA,M;AACA,4B;AACA,+B;AACA,2D;AACA,sB;AACA,K;AACA,K;AACA,wB;;AAEA,iE;AACA,iD;AACA,2B;AACA,4C;AACA,wB;AACA,0B;AACA,e;AACA,O;AACA,sB;AACA,M;AACA,0B;AACA,sB;AACA,K;AACA,K;AACA,wB;;AAEA,kB;AACA,e;;AAEA,mD;AACA,gD;AACA,qD;AACA,2B;AACA,mB;AACA,mB;AACA,K;AACA,G","file":"/packages/aldeed_tabular.js","sourcesContent":["/* global Tabular:true, tablesByName:true, Mongo, _, Meteor */\n\nTabular = {}; //exported\n\ntablesByName = {};\n\nTabular.Table = function (options) {\n  var self = this;\n\n  if (!options) {\n    throw new Error('Tabular.Table options argument is required');\n  }\n\n  if (!options.name) {\n    throw new Error('Tabular.Table options must specify name');\n  }\n  self.name = options.name;\n\n  if (!(options.collection instanceof Mongo.Collection)) {\n    throw new Error('Tabular.Table options must specify collection');\n  }\n  self.collection = options.collection;\n\n  self.pub = options.pub || 'tabular_genericPub';\n\n  // By default we use core `Meteor.subscribe`, but you can pass\n  // a subscription manager like `sub: new SubsManager({cacheLimit: 20, expireIn: 3})`\n  self.sub = options.sub || Meteor;\n\n  self.onUnload = options.onUnload;\n  self.allow = options.allow;\n  self.allowFields = options.allowFields;\n  self.changeSelector = options.changeSelector;\n\n  if (_.isArray(options.extraFields)) {\n    var fields = {};\n    _.each(options.extraFields, function (fieldName) {\n      fields[fieldName] = 1;\n    });\n    self.extraFields = fields;\n  }\n\n  self.selector = options.selector;\n\n  if (!options.columns) {\n    throw new Error('Tabular.Table options must specify columns');\n  }\n\n  self.options = _.omit(options, 'collection', 'pub', 'sub', 'onUnload', 'allow', 'allowFields', 'extraFields', 'name', 'selector');\n\n  tablesByName[self.name] = self;\n};\n","/* global check, Match, Meteor, tablesByName, _ */\n\n/*\n * These are the two publications used by TabularTable.\n *\n * The genericPub one can be overridden by supplying a `pub`\n * property with a different publication name. This publication\n * is given only the list of ids and requested fields. You may\n * want to override it if you need to publish documents from\n * related collections along with the table collection documents.\n *\n * The getInfo one runs first and handles all the complex logic\n * required by this package, so that you don't have to duplicate\n * this logic when overriding the genericPub function.\n *\n * Having two publications also allows fine-grained control of\n * reactivity on the client.\n */\n\nMeteor.publish(\"tabular_genericPub\", function (tableName, ids, fields) {\n  var self = this;\n\n  check(tableName, String);\n  check(ids, Array);\n  check(fields, Match.Optional(Object));\n\n  var table = tablesByName[tableName];\n  if (!table) {\n    // We throw an error in the other pub, so no need to throw one here\n    self.ready();\n    return;\n  }\n\n  // Extend fields list with extra fields from the table definition\n  if (table.extraFields) {\n    _.extend(fields, table.extraFields);\n  }\n\n  // Check security. We call this in both publications.\n  if (typeof table.allow === 'function' && !table.allow(self.userId, fields)) {\n    self.ready();\n    return;\n  }\n\n  // Check security for fields. We call this only in this publication\n  if (typeof table.allowFields === 'function' && !table.allowFields(self.userId, fields)) {\n    self.ready();\n    return;\n  }\n\n  return table.collection.find({_id: {$in: ids}}, {fields: fields});\n});\n\nMeteor.publish(\"tabular_getInfo\", function(tableName, selector, sort, skip, limit) {\n  var self = this;\n\n  check(tableName, String);\n  check(selector, Match.Optional(Match.OneOf(Object, null)));\n  check(sort, Match.Optional(Match.OneOf(Array, null)));\n  check(skip, Number);\n  check(limit, Number);\n\n  var table = tablesByName[tableName];\n  if (!table) {\n    throw new Error('No TabularTable defined with the name \"' + tableName + '\". Make sure you are defining your TabularTable in common code.');\n  }\n\n  // Verify that limit is not 0, because that will actually\n  // publish all document _ids.\n  if (limit === 0) {\n    limit = 1;\n  }\n\n  // Check security. We call this in both publications.\n  // Even though we're only publishing _ids and counts\n  // from this function, with sensitive data, there is\n  // a chance someone could do a query and learn something\n  // just based on whether a result is found or not.\n  if (typeof table.allow === 'function' && !table.allow(self.userId)) {\n    self.ready();\n    return;\n  }\n\n  selector = selector || {};\n\n  // Allow the user to modify the selector before we use it\n  if (typeof table.changeSelector === 'function') {\n    selector = table.changeSelector(selector, self.userId);\n  }\n\n  // Apply the server side selector specified in the tabular\n  // table constructor. Both must be met, so we join\n  // them using $and, allowing both selectors to have\n  // the same keys.\n  if (typeof table.selector === 'function') {\n    var tableSelector = table.selector(self.userId);\n    if (_.isEmpty(selector)) {\n      selector = tableSelector;\n    } else {\n      selector = {$and: [tableSelector, selector]};\n    }\n  }\n\n  var findOptions = {\n    skip: skip,\n    limit: limit,\n    fields: {_id: 1}\n  };\n\n  // `sort` may be `null`\n  if (_.isArray(sort)) {\n    findOptions.sort = sort;\n  }\n\n  var filteredCursor = table.collection.find(selector, findOptions);\n\n  var filteredRecordIds = filteredCursor.map(function (doc) {\n    return doc._id;\n  });\n\n  var countCursor = table.collection.find(selector, {fields: {_id: 1}});\n\n  var recordReady = false;\n  function updateRecords() {\n    var currentCount = countCursor.count();\n\n    var record = {\n      ids: filteredRecordIds,\n      // count() will give us the updated total count\n      // every time. It does not take the find options\n      // limit into account.\n      recordsTotal: currentCount,\n      recordsFiltered: currentCount\n    };\n\n    if (recordReady) {\n      //console.log(\"changed\", tableName, record);\n      self.changed('tabular_records', tableName, record);\n    } else {\n      //console.log(\"added\", tableName, record);\n      self.added(\"tabular_records\", tableName, record);\n      recordReady = true;\n    }\n  }\n\n  // Handle docs being added or removed from the result set.\n  var initializing1 = true;\n  var handle1 = filteredCursor.observeChanges({\n    added: function (id) {\n      if (initializing1) {\n        return;\n      }\n\n      //console.log(\"ADDED\");\n      filteredRecordIds.push(id);\n      updateRecords();\n    },\n    removed: function (id) {\n      //console.log(\"REMOVED\");\n      filteredRecordIds = _.without(filteredRecordIds, id);\n      updateRecords();\n    }\n  });\n  initializing1 = false;\n\n  // Handle docs being added or removed from the non-limited set.\n  // This allows us to get total count available.\n  var initializing2 = true;\n  var handle2 = countCursor.observeChanges({\n    added: function () {\n      if (initializing2) {\n        return;\n      }\n      updateRecords();\n    },\n    removed: function () {\n      updateRecords();\n    }\n  });\n  initializing2 = false;\n\n  updateRecords();\n  self.ready();\n\n  // Stop observing the cursors when client unsubs.\n  // Stopping a subscription automatically takes\n  // care of sending the client any removed messages.\n  self.onStop(function () {\n    handle1.stop();\n    handle2.stop();\n  });\n});\n"]}